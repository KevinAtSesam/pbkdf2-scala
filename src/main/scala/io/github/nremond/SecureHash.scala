/**
 * Copyright 2012-2014 Nicolas RÃ©mond (@nremond)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package io.github.nremond

import java.nio.ByteBuffer
import java.security.SecureRandom
import java.util.Base64

import scala.io.Codec.UTF8
import scala.util.Try

/**
 * Implements functionality to create and validate password hashes using [[PBKDF2]]
 */
object SecureHash {

  import internals._

  /**
   * Creates a hashed password using [[PBKDF2]]
   *
   * this function output a string in the modified MCF format :
   *
   * p0\$params\$salt\$key
   *
   *  - p0 : version 0 of the format
   *
   *  - params: 8 digit hexadecimal representation of the number of iterations concatenated with the algo name
   *
   *  - salt : Base64 encoded salt
   *
   *  - key : Base64 encoded derived key
   *
   * Example :
   *
   * p0\$00004e20HmacSHA256\$mOCtN/Scjry0uIALe4bCCrL9eL8aWEA/\$hDxtqCnBF1MS5qIOxHeDAZ23QEmqdL7796I0pVJ2yvQ=
   *
   * @param password  the password to hash
   * @param iterations the number of encryption iterations. Default to 20000
   * @param dkLength derived-key length, default to 32
   * @param cryptoAlgo HMAC+SHA256 is the default as HMAC+SHA1 is now considered weak
   */
  def createHash(password: String, iterations: Int = 20000, dkLength: Int = 32, cryptoAlgo: String = "HmacSHA256"): String = {
    val salt = {
      val b = new Array[Byte](24)
      (new SecureRandom).nextBytes(b)
      b
    }
    val key = PBKDF2(password.getBytes(UTF8.charSet), salt, iterations, dkLength, cryptoAlgo)
    encode(salt, key, iterations, cryptoAlgo)
  }

  /**
   * Validate a password against a password hash
   *
   * @param password the password to validate
   * @param hashedPassword the password hash. This should be in the same format as generated by [[SecureHash.createHash]]
   * @return true is the password is valid
   */
  def validatePassword(password: String, hashedPassword: String): Boolean = decode(hashedPassword) match {
    case Some(decoded) =>
      decoded.key.sameElements(PBKDF2(password.getBytes(UTF8.charSet), decoded.salt, decoded.iterations, decoded.key.length, decoded.algo))
    case _ => false
  }

  private[nremond] object internals {
    def encode(salt: Array[Byte], key: Array[Byte], iterations: Int, algo: String): String = {
      val iters = toHex(ByteBuffer.allocate(4).putInt(iterations).array())
      s"$$p0$$$iters$algo$$${b64Encoder(salt)}$$${b64Encoder(key)}"
    }

    case class Decoded(version: String, iterations: Int, algo: String, salt: Array[Byte], key: Array[Byte])

    def decode(s: String): Option[Decoded] = Try {
      s match {
        case rx(i, a, s, h) => Some(Decoded("p0", ByteBuffer.wrap(fromHex(i)).getInt, a, b64Decoder(s), b64Decoder(h)))
        case _              => None
      }

    }.toOption.getOrElse(None)

    val rx = "\\$p0\\$([0-9a-fA-F]{8})([^\\$]+)\\$([^\\$]*)\\$([^\\$]*)".r
    val b64Decoder = Base64.getDecoder.decode(_: String)
    val b64Encoder = Base64.getEncoder.encodeToString _
  }
}
